# 如何确定一个问题是 DP 问题

> 来自 [三叶](https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtd7d2/)

1. **如何确定一个问题是 DP 问题。**

理解 DP 问题的核心需要理解他是一个数学问题，我们需要列出一个符合两个至关重要的特性——最优子结构以及无后效性的方程。

>  最优子结构：需要理解为一个状态机
>
> ```
> -----------							-----------
> |					|							|					|
> |		f(x)  |	---------> 	|	f(x+1)  |
> |					|							|					|
> -----------							-----------
> 对于一个最优值 f(x+1)，他一定能表示为最优状态 f(x) 的线性函数
> ```
>
> 无后效性：**给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关**；**对于给定的这个确定状态，他本身是由过去的有限状态转换而来**。
>
> 也即，对于一个确定的最优值 $f(x)$，其下一个最优值一定源于 $f(x)$，而不是 $f(x-n) \ n \in (0,x)$ ；对于一个确定的最优值 $f(x)$，他一定源于过去有限的状态 $f(x-n) \ n \in (0,x) $ 的线性和。
>

2. **如何定义一个方程**

说实话，DP 的状态定义很大程度是靠经验去猜的。虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联的。实际上我们定义状态时都会优先根据最优子结构来做，先将其看为可以抽象出来的子问题，看到状态过渡，然后将最优值定义为函数。

3. **如何确定状态的转移**

通常来说，如果我们的状态定义猜对了，状态转移方程就是对「最后一步的分情况讨论」。

大多数情况下，如果我们有一个对的状态定义的话，基本上状态转移方程就是呼之欲出。

因此一定程度上，状态转移方程可以反过来验证我们状态定义猜得是否正确：**如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程**。

4. **状态转移需要覆盖什么情况**

我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：

如果是求最值的话，我们只需要确保「不漏」即可，因为重复不影响结果。如果是求方案数的话，我们需要确保「不重不漏」。

5. **我们是如何分析动态规划的时间复杂度的？**

对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少(从计算公式上一眼就能看出来)。

因此一维 DP 的复杂度通常是线性的 $O(n)$，而二维 DP 的复杂度通常是平方的 $O(n^2)$。

