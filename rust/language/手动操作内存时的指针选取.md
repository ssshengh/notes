# 如何选取纷繁复杂的底层指针

> 大量参考了：https://github.com/Warrenren/inside-rust-std-library/blob/main/02-%E5%86%85%E5%AD%98.md
>
> 对我不太理解的地方做了新的解释，并添加了选型的考虑以及实际使用的 case

在写 Rust 的时候经常会发现虽然官方推荐的 RC、Cell、RefCell、Box 等指针样样好，但是一看开源库，不是`*mut T`就是`NonNull`、`ManuallyDrop`等底层类型。在我自己编写 Rust 代码的时候就会很困惑，我究竟应该选择什么类型？我手动操作内存应该是手动到什么程度？

这篇文章的核心目标就是为几个底层指针做一个选型的建议，其中主要包括的是：

1. 裸指针：`*mut T`, `*const T`
2. 引用：`&T`, `&mut T`

3. `core::ptr`模块，主要是`NonNull`指针
4. `core::mem`模块，主要是`ManuallyDrop`指针
5. 智能指针及堆分配

# 裸指针

裸指针`*const T/* mut T`将内存和类型系统相连接，裸指针代表了一个内存块，指示了内存块首地址、大小、对齐等属性及后文提到的元数据，但**不保证这个内存块的有效性和安全性**。因此在 Rust 中直接修改裸指针是 unsafe 的。
与`*const T/* mut T`不同，`&T/&mut T`则保证内存块是安全和有效的，即`&T/&mut T`满足内存块首地址内存对齐，内存块已经完成了初始化。在RUST中，`&T/&mut T`是被绑定在某一内存块上，只能用于读写这一内存块。

对内存块的各种 C 模式的操作，基本都是通过裸指针完成：

1. 64位机器上，将 usize 类型数值强制转换成裸指针类型`*const T`或者`*mut T`，以此数值为首地址的内存块也将被转换为相应的类型 T，但是这是 unsafe 的，需要用户确保数据信息的正确性。

2. 在不同的裸指针类型 T 之间进行强制转换，实质上完成了裸指针指向的内存块的类型强转，如果对这一转换后的内存块进行读写，可能造成内存安全问题。

3. `*const u8`为堆内存申请的内存块绑定变量，或者说 u8 本身涵盖了内存地址的含义。
4. 内存赋值
5. 内存偏移
6. 内存拷贝
7. FFI，跨语言接口，一般是通过 C ABI 完成，例如 Rust 接 Go 需要强转为裸指针。
8. 。。。

## 原理

在`core::ptr::metedata`中能够找到这么一段注释：

> Raw pointer types and reference types in Rust can be thought of as made of two parts: a data pointer that contains the memory address of the value, and some metadata.
>
> * For statically-sized types (that implement the Sized traits) as well as for extern types, pointers are said to be “thin”: metadata is zero-sized and its type is ().
> * Pointers to dynamically-sized types  are said to be “wide” or “fat”, they have non-zero-sized metadata:
> * For structs whose last field is a DST, metadata is the metadata for the last field
> * For the str type, metadata is the length in bytes as usize
> * For slice types like [T], metadata is the length in items as usize
> * For trait objects like dyn SomeTrait, metadata is DynMetadata<Self> (e.g. DynMetadata<dyn SomeTrait>)
> * In the future, the Rust language may gain new kinds of types that have different pointer metadata.
>
> 
>
> Rust中的原始指针类型和引用类型可以被认为由两部分组成：包含值的内存地址的数据指针和一些元数据。
>
> * 对于**静态大小的类型**（实现了Sized trait）以及外部类型，指针被称为“thin”：元数据大小为零，其类型为()。
> * 对于**动态大小的类型**，指针被称为“wide”或“fat”，它们具有非零大小的元数据：
> * 对于最后一个字段为DST的结构体，元数据是最后一个字段的元数据。
> * 对于str类型，元数据是以usize计算的字节长度。
> * 对于像[T]这样的切片类型，元数据是以usize计算的项数长度。
> * 对于像dyn SomeTrait这样的特征对象，元数据是DynMetadata<Self>（例如DynMetadata<dyn SomeTrait>）。
> * 未来，Rust语言可能会获得具有不同指针元数据的新类型。

可以看到在 Rust 中指针不是简单的一个地址，而是有着两部分组成的数据结构，其“胖瘦”是由指向的数据类型决定的，动态类型就是胖的，静态类型是瘦的。具体的实现如下：

```rust
// 一个 Rust 应用中建议不使用的 Union 结构体，从下面结构定义可以看到，裸指针本质就是PtrComponents<T>
#[repr(C)]
union PtrRepr<T: ?Sized> {
    const_ptr: *const T,
    mut_ptr: *mut T,
    components: PtrComponents<T>,
}

// 数据的地址是个 unit 类型：()
// 这个很重要，它类似于 C 的 *void 类型，但是又不太一样，更多的含义是，不 care 它是个啥类型或者说是否有它
#[repr(C)]
struct PtrComponents<T: ?Sized> {
    data_address: *const (),
    metadata: <T as Pointee>::Metadata,
}

// Pointee 的定义展示了一个 Rust 的编程技巧，即 trait 可以只用
// 来定义关联类型，Pointee 即只用来指定 Metadata 的类型。
pub trait Pointee {
    /// The type for metadata in pointers and references to `Self`.
    type Metadata: Copy + Send + Sync + Ord + Hash + Unpin;
}
// 廋指针
pub trait Thin = Pointee<Metadata = ()>;
```

在上面的结构体`PtrRepr`中，依据 Uinon 结构体的特性，我们可以知道，对于瘦指针来说，确实只有一个地址，因为`metadata`为 unit 类型，其大小为 0，union 结构体的大小就只有指针大小，但是如果是胖指针就会带上`metadata`的大小，而胖指针（这里特指 trait object类型）的元数据定义如下：

```rust
#[lang = "dyn_metadata"]
pub struct DynMetadata<Dyn: ?Sized> {
    vtable_ptr: &'static VTable,
    phantom: crate::marker::PhantomData<Dyn>,
}

extern "C" {
    /// Opaque type for accessing vtables.
    ///
    /// Private implementation detail of `DynMetadata::size_of` etc.
    /// There is conceptually not actually any Abstract Machine memory behind this pointer.
    type VTable;
}

//此结构是实际的trait实现
struct VTable {
    //trait对象的drop方法的指针
    drop_in_place: fn(*mut ()),
    //trait对象的内存大小
    size_of: usize,
    //trait对象的内存对齐
    align_of: usize,
    //后继是trait对象的所有方法的指针数组
}
```

通过注释可以知道，`Dyn = dyn SomeTrait` 对象类型的元数据含义包含以下几方面：

1. 它是指向虚函数表（virtual call table）的指针，表示操纵储存在特质对象内的具体类型所需的所有信息。虚函数表明显包括以下内容：
   1. 类型大小
   2. 类型对齐
   3. 指向类型 drop_in_place 实现的指针（对于普通数据可能是空操作）
   4. 指向类型实现特质的所有方法的指针
   5. 请注意，前三个因为对于分配、释放和撤销任何 Dyn 对象是必要的，所以是特殊的。

在标准库代码当中没有指针类型如何实现Pointee Trait的代码，编译器针对每个类型自动的实现了Pointee。 如下为rust编译器代码的一个摘录

```Rust
    pub fn ptr_metadata_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {
        // FIXME: should this normalize?
        let tail = tcx.struct_tail_without_normalization(self);
        match tail.kind() {
            // Sized types
            ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
            | ty::Uint(_)
            | ty::Int(_)
            | ty::Bool
            | ty::Float(_)
            | ty::FnDef(..)
            | ty::FnPtr(_)
            | ty::RawPtr(..)
            | ty::Char
            | ty::Ref(..)
            | ty::Generator(..)
            | ty::GeneratorWitness(..)
            | ty::Array(..)
            | ty::Closure(..)
            | ty::Never
            | ty::Error(_)
            | ty::Foreign(..)
            | ty::Adt(..)
            // 如果是固定类型，元数据是单元类型 tcx.types.unit，即为空
            | ty::Tuple(..) => tcx.types.unit,

            //对于字符串和切片类型，元数据为长度tcx.types.usize，是元素长度
            ty::Str | ty::Slice(_) => tcx.types.usize,

            //对于dyn Trait类型， 元数据从具体的DynMetadata获取*
            ty::Dynamic(..) => {
                let dyn_metadata = tcx.lang_items().dyn_metadata().unwrap();
                tcx.type_of(dyn_metadata).subst(tcx, &[tail.into()])
            },
            
            //以下类型不应有元数据
            ty::Projection(_)
            | ty::Param(_)
            | ty::Opaque(..)
            | ty::Infer(ty::TyVar(_))
            | ty::Bound(..)
            | ty::Placeholder(..)
            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
                bug!("`ptr_metadata_ty` applied to unexpected type: {:?}", tail)
            }
        }
    }
```

## 常见操作

典型的例子是用于申请内存并手动管理，例如库`crossbeam`中`deque.rs`中盗窃并发队列的 task 抽象的实现：

```Rust
// A buffer that holds tasks in a worker queue.
///
/// This is just a pointer to the buffer and its length - dropping an instance of this struct will
/// *not* deallocate the buffer.
struct Buffer<T> {
    /// Pointer to the allocated memory.
    ptr: *mut T,

    /// Capacity of the buffer. Always a power of two.
    cap: usize,
}
```

使用裸指针的一个很重要的原因就是，在 drop `Buffer`时不会去 deallocate 内部的数据，而是需要手动去处理，其实现的方法也比较简单，就只有四个，但是都是很典型的内存操作：

```Rust
impl<T> Buffer<T> {
    /// Allocates a new buffer with the specified capacity.
    /// 手动分配内存，可以看到通过 ManuallyDrop 来进行的
    fn alloc(cap: usize) -> Buffer<T> {
        debug_assert_eq!(cap, cap.next_power_of_two());

        let mut v = ManuallyDrop::new(Vec::with_capacity(cap));
        let ptr = v.as_mut_ptr();

        Buffer { ptr, cap }
    }

    /// Deallocates the buffer.
  	/// 手动释放内存
    unsafe fn dealloc(self) {
        drop(Vec::from_raw_parts(self.ptr, 0, self.cap));
    }

    /// Returns a pointer to the task at the specified `index`.
  	/// 通过偏移读取数据，很 C 的操作
    unsafe fn at(&self, index: isize) -> *mut T {
        // `self.cap` is always a power of two.
        // We do all the loads at `MaybeUninit` because we might realize, after loading, that we
        // don't actually have the right to access this memory.
        self.ptr.offset(index & (self.cap - 1) as isize)
    }

    /// Writes `task` into the specified `index`.
    ///
    /// This method might be concurrently called with another `read` at the same index, which is
    /// technically speaking a data race and therefore UB. We should use an atomic store here, but
    /// that would be more expensive and difficult to implement generically for all types `T`.
    /// Hence, as a hack, we use a volatile write instead.
  	/// volatile 写，禁止内存优化，直接写到内存里
    unsafe fn write(&self, index: isize, task: MaybeUninit<T>) {
        ptr::write_volatile(self.at(index).cast::<MaybeUninit<T>>(), task)
    }

    /// Reads a task from the specified `index`.
    ///
    /// This method might be concurrently called with another `write` at the same index, which is
    /// technically speaking a data race and therefore UB. We should use an atomic load here, but
    /// that would be more expensive and difficult to implement generically for all types `T`.
    /// Hence, as a hack, we use a volatile load instead.
  	/// volatile 读，禁止内存优化，直接读取内存信息，而不是从缓存读
    unsafe fn read(&self, index: isize) -> MaybeUninit<T> {
        ptr::read_volatile(self.at(index).cast::<MaybeUninit<T>>())
    }
}
```

其真正的 Drop 的实现如下：

```Rust
/// 一系列 task 的抽象
struct Inner<T> {
    /// The front index.
    front: AtomicIsize,

    /// The back index.
    back: AtomicIsize,

    /// The underlying buffer. 注意处理了内存对齐。
    buffer: CachePadded<Atomic<Buffer<T>>>,
}

impl<T> Drop for Inner<T> {
    fn drop(&mut self) {
        // Load the back index, front index, and buffer.
        let b = *self.back.get_mut();
        let f = *self.front.get_mut();

        unsafe {
            let buffer = self.buffer.load(Ordering::Relaxed, epoch::unprotected());

            // Go through the buffer from front to back and drop all tasks in the queue.
            let mut i = f;
            while i != b {
              	// drop 每一个 buffer 中的 task
                buffer.deref().at(i).drop_in_place();
                i = i.wrapping_add(1);
            }

            // Free the memory allocated by the buffer.
            buffer.into_owned().into_box().dealloc();
        }
    }
}
```

# 附录

## intrinsic模块内存相关固有函数

intrinsics模块中的函数由编译器内置实现，并提供给其他模块使用。固有函数标准库没有代码，所以对其主要是了解功能和如何使用，intrinsics模块的内存函数一般不由库以外的代码直接调用，而是由mem模块和ptr模块封装后再提供给其他模块。

**内存申请及释放函数**：

> `intrinsics::forget<T:Sized?> (_:T)`, 代码中调用这个函数后，在变量生命周期终止时，编译器不会调用变量的drop函数。
>
> `intrinsics::drop_in_place<T:Sized?>(to_drop: * mut T)` 在forget后，如果仍然需要对变量调用drop，则在代码中显式调用此函数以触发对变量的drop调用。
>
> `intrinsics::needs_drop<T>()->bool`, 判断T类型是否需要做drop操作，实现了Copy trait的类型会返回false

**类型转换**：

> `intrinsics::transmute<T,U>(e:T)->U`, 对于内存布局相同的类型 T和U, 完成将类型T变量转换为类型U变量，此时T的所有权将转换为U的所有权

**指针偏移函数**:

> `intrinsics::offset<T>(dst: *const T, offset: usize)->* const T`, 相当于C的基于类型的指针加计算
> `intrinsics::ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize` 相当于C的基于类型的指针减

**内存块内容修改函数**:

> `intrinsics::copy<T>(src:*const T, dst: *mut T, count:usize)`, 内存拷贝， src和dst内存可重叠， 类似c语言中的memmove, 此时dst原有内存如果已经初始化，dst原有变量的drop实质会不执行。src的变量可能出现两次drop，因此调用此函数的代码需要处理这种情况。`intrinsics::copy_no_overlapping<T>(src:*const T, dst: * mut T, count:usize)`, 内存拷贝， src和dst内存不重叠，内存安全问题同上
>
> `intrinsics::write_bytes(dst: *mut T, val:u8, count:usize)` , C语言的memset的RUST实现, 此时，原内存如果已经初始化，则因为编译器会继续对dst的内存块做drop调用，有可能会UB。

**类型内存参数函数**：

> `intrinsics::size_of<T>()->usize` 类型内存空间字节数
> `intrinsics::min_align_of<T>()->usize` 返回类型对齐字节数
> `intrinsics::size_of_val<T>(_:*const T)->usize`返回指针指向的变量内存空间字节数
> `intrinsics::min_align_of_val<T>(_: * const T)->usize` 返回指针指向的变量对齐字节数

**禁止优化的内存函数**：

> 形如`volatile_xxxx` 的函数是通知编译器不做内存优化的操作函数,一般硬件相关操作需要禁止优化。
> `intrinsics::volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize)` 内存拷贝`intrinsics::volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize)` 功能类似C语言memmove
>
> `intrinsics::volatile_set_memory<T>(dst: *mut T, val: u8, count: usize)` 功能类似C语言memset
>
> `intrinsics::volatile_load<T>(src: *const T) -> T`读取内存或寄存器，T类型字节对齐到2的幂次
>
> `intrinsics::volatile_store<T>(dst: *mut T, val: T)`内存或寄存器写入，字节对齐
>
> `intrinsics::unaligned_volatile_load<T>(src: *const T) -> T` 字节非对齐
>
> `intrinsics::unaligned_volatile_store<T>(dst: *mut T, val: T)`字节非对齐

**内存比较函数**：

> `intrinsics::raw_eq<T>(a: &T, b: &T) -> bool` 内存比较，类似C语言memcmp
>
> `pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否判断, 相等返回ture, 不等返回false
>
> `pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否不等，不等返回true

## 裸指针操作函数

**创建裸指针**：

```Rust
// 引用转换
&T as *const T;
&mut T as * mut T;

// 从 uszie 转换，直接将一个地址数值转换为某一类型的裸指针
{
    let  a: usize = 0xf000000000000000;
    unsafe {a as * const i32};
}
```

**RUST也提供了一些其他的裸指针创建关联函数**：

> `ptr::null<T>() -> *const T` 创建一个0值的`*const T`，实际上就是 `0 as *const T`，用null()函数明显更符合程序员的习惯
> `ptr::null_mut<T>()->*mut T` 除了类型以外，其他同上
>
> `ptr::invalid<T>(addr:usize)->*mut T` 将一个数值作为裸指针，指明这是一个无效的裸指针。
> `ptr::invalid_mut<T>(addr:usize)->*mut T` 将一个数值作为可变裸指针，指明这是一个无效的指针。
> 以上两个函数通常是将指针变量用作他途以提高新能
>
> `ptr::from_raw_parts<T: ?Sized>(data_address: *const (), metadata: <T as Pointee>::Metadata) -> *const T` 从内存地址和元数据创建裸指针
>
> `ptr::from_raw_parts_mut<T: ?Sized>(data_address: *mut (), metadata: <T as Pointee>::Metadata) -> *mut T` 功能同上，创建可变裸指针

**切片类型的裸指针创建函数如下**：

> `ptr::slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] `
> `ptr::slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T]` 由裸指针类型及切片长度获得切片类型裸指针，调用代码应保证data事实上就是切片的裸指针地址。
>
> 
>
> 由类型裸指针转换为切片类型裸指针最突出的应用之一是内存申请，申请的内存返回 * const u8的指针，这个裸指针是没有包含内存大小的，只有头地址，因此需要将这个指针转换为 * const [u8]，将申请的内存大小包含入裸指针结构体中。

**不属于方法的裸指针函数**:

> `ptr::drop_in_place<T: ?Sized>(to_drop: *mut T)` 此函数是编译器实现的，用于由程序代码人工释放所有权，而不是交由RUST编译器处理。此函数会引发T内部成员的系列drop调用。
>
> `ptr::metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata `用来返回裸指针的元数据
>
> `ptr::eq<T>(a: *const T, b: *const T)->bool` 比较指针，此处需要注意，地址比较不但是地址，也比较元数据

ptr模块的函数大部分逻辑都比较简单。很多就是对intrinsic 函数的直接调用。

**裸指针类型转换方法**:

> 裸指针类型之间的转换： `*const T::cast<U>(self) -> *const U ` ，本质上就是一个`*const T as *const U`。利用RUST的类型推断，此函数可以简化代码并支持链式调用。 `*mut T::cast<U>(self)->*mut U` 同上。

调用以上的函数要注意，如果后继要把返回的指针转换成引用，那必须保证T类型与U类型内存布局完全一致。如果仅仅是将返回值做数值应用，则此约束可以不遵守，cast函数转换后的类型通常由编译器自行推断，有时需要仔细分析。

**裸指针与引用之间的类型转换**：

> `*const T::as_ref<‘a>(self) -> Option<&’a T>` 将裸指针转换为引用，因为*const T可能为零，所有需要转换为`Option<& ‘a T>`类型，转换的安全性由程序员保证，尤其注意满足RUST对引用的安全要求。这里注意，**生命周期标注表明转换后的生命周期实际上与原变量的生命周期相独立**。因此，生命周期的正确性将由调用代码保证。如果没有标注，则返回的引用的生命周期应该小于self,遵循函数参数及返回值的生命周期规则。
> `*mut T::as_ref<`a>(self)->Option<&`a T>` 同上
> `*mut T::as_mut<`a>(self)->Option<&`a mut T>`同上，但转化类型为 &mut T。

**切片类型裸指针类型转换**：

> `ptr::*const [T]::as_ptr(self) -> *const T` 将切片类型的裸指针转换为切片成员类型的裸指针， 这个转换会导致指针的元数据丢失
> `ptr::*mut [T]::as_mut_ptr(self) -> *mut T` 同上

**裸指针结构体属性相关方法**：

> `ptr::*mut T::to_raw_parts(self)->(* const (), <T as super::Pointee>::Metadata)` 由裸指针获得地址及元数据
> `ptr::*const T::is_null(self)->bool`
> `ptr::*mut T::is_null(self)->bool此`函数判断裸指针的地址值是否为0
>
> 

**切片类型裸指针**：

> `ptr::*const [T]:: len(self) -> usize` 获取切片长度，直接从裸指针的元数据获取长度
> `ptr:: *mut [T]:: len(self) -> usize` 同上

**裸指针偏移计算相关方法**:

> `ptr::*const T::offset(self, count:isize)->* const T` 得到偏移后的裸指针
> `ptr::*const T::wrapping_offset(self, count: isize) -> *const T` 考虑溢出绕回的offset
> `ptr::*const T::offset_from(self, origin: *const T) -> isize` 计算两个裸指针的offset值
> `ptr::*mut T::offset(self, count:isize)->* mut T` 偏移后的裸指针
> `ptr::*const T::wrapping_offset(self, count: isize) -> *const T` 考虑溢出绕回的offset
> `ptr::*const T::offset_from(self, origin: *const T) -> isize` 计算两个裸指针的offset值
> 以上两个方法基本上通过intrinsic的函数实现

> `ptr::*const T::add(self, count: usize) -> Self`
> `ptr::*const T::wraping_add(self, count: usize)->Self`
> `ptr::*const T::sub(self, count:usize) -> Self`
> `ptr::*const T::wrapping_sub(self, count:usize) -> Self`
> `ptr::*mut T::add(self, count: usize) -> Self`
> `ptr::*mut T::wraping_add(self, count: usize)->Self`
> `ptr::*mut T::sub(self, count:usize) -> Self`
> `ptr::*mut T::wrapping_sub(self, count:usize) -> Self`
> 以上是对offset函数的包装，使之更符合语义习惯，并便于理解