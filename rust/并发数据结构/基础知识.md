# åŸºç¡€çŸ¥è¯†

åœ¨å¹¶å‘åœºæ™¯ä¸­ï¼Œå†…å­˜çš„æ§åˆ¶å˜å¾—è¾ƒä¸ºå¾®å¦™ï¼Œè¿™ä¸€ç¯‡åŸºç¡€çŸ¥è¯†ä¸»è¦æ˜¯æ¶µç›–äº†å†…å­˜é¡ºåºå’Œå†…å­˜æ§åˆ¶æ–¹é¢çš„é«˜çº§çŸ¥è¯†ã€‚

# CachePadded

crossbeam ä¸­æä¾›äº†ä¸€ä¸ªè¾…åŠ©çš„æ•°æ®ç»“æ„`CachePadded`ï¼Œå®ƒçš„ä¸»è¦ä½œç”¨æ˜¯ï¼š

> - åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œæ›´æ–°åŸå­å€¼ä¼šä½¿å…¶æ‰€åœ¨çš„æ•´ä¸ªç¼“å­˜è¡Œå¤±æ•ˆï¼Œè¿™å°†å¯¼è‡´åœ¨å…¶ä»–CPUå†…æ ¸ä¸Šè®¿é—®è¯¥ç¼“å­˜è¡Œçš„é€Ÿåº¦ä¸‹é™ã€‚
> - `CachePadded`ç±»å¯ä»¥ç¡®ä¿æ›´æ–°ä¸€éƒ¨åˆ†æ•°æ®ä¸ä¼šä½¿å…¶ä»–ç¼“å­˜æ•°æ®å¤±æ•ˆï¼Œä¸»è¦æ˜¯é€šè¿‡æ›´æ”¹ aligment è¾¾åˆ°ç›®çš„çš„ã€‚
> - è®¾å¤‡ä¸Šçš„ç¼“å­˜è¡Œé•¿åº¦å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒï¼Œæ–‡æœ¬åˆ—ä¸¾äº†x86-64, aarch64, powerpc64ç­‰å„ç±»è®¾å¤‡ä¸Šçš„ç¼“å­˜è¡Œé•¿åº¦å‡è®¾å€¼ã€‚
> - `CachePadded<T>`çš„å¤§å°æ˜¯å¯ä»¥å®¹çº³ç±»å‹ä¸º`T`çš„å€¼çš„Nå­—èŠ‚çš„æœ€å°å€æ•°ï¼Œå…¶ä¸­Nä¸ºè®¾å¤‡ä¸Šçš„ç¼“å­˜è¡Œé•¿åº¦ï¼›`CachePadded<T>`çš„å¯¹é½æ–¹å¼ä¸ºNå­—èŠ‚å’Œ`T`çš„å¯¹é½æ–¹å¼ä¸­çš„è¾ƒå¤§è€…ã€‚

## å†…å­˜å¯¹é½ä¸ç¼“å­˜

### å¯¹é½

è¿™é‡Œéœ€è¦å›é¡¾ä¸€ä¸‹ CPU å¯¹é½ä¸ç¼“å­˜çš„åŸºç¡€çŸ¥è¯†ï¼Œæ•°æ®çš„alignmentï¼ˆå¯¹é½ï¼‰åœ¨è®¡ç®—æœºç³»ç»Ÿä¸­ä¸»è¦å½±å“ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š

1. **æ€§èƒ½**ï¼šæ•°æ®å¯¹é½å¯ä»¥åŠ å¿«å†…å­˜è®¿é—®çš„é€Ÿåº¦ã€‚å½“æ•°æ®ä¸ç¡¬ä»¶çš„å‚¨å­˜å•å…ƒå¯¹é½æ—¶ï¼ŒCPUå¯ä»¥ä¸€æ¬¡è¯»å–å®Œæ•´çš„æ•°æ®å—ï¼Œè€Œä¸éœ€è¦åˆ†å¤šæ¬¡è¯»å–ã€‚è‹¥æ•°æ®ä¸å¯¹é½ï¼Œç”µè„‘å¯èƒ½éœ€è¦ç”¨æ›´å¤šçš„CPUå‘¨æœŸæ¥è¯»å†™æ•°æ®ï¼Œä»è€Œå¯¼è‡´æ€§èƒ½é™ä½ã€‚
2. **ç¡¬ä»¶è¦æ±‚**ï¼šæŸäº›ç¡¬ä»¶å¹³å°è¦æ±‚æ•°æ®åœ¨å†…å­˜ä¸­ä»¥ç‰¹å®šæ–¹å¼å¯¹é½ã€‚å¦‚ï¼Œåœ¨æŸäº›CPUæ¶æ„ä¸­ï¼Œå¦‚æœæŸç±»å‹çš„æ•°æ®ä¸å¯¹é½ï¼Œå°†å¯¼è‡´ç¡¬ä»¶å¼‚å¸¸å’Œç¨‹åºå´©æºƒã€‚
3. **å†…å­˜ä½¿ç”¨**ï¼šæ•°æ®å¯¹é½å¯èƒ½ä¼šå¯¼è‡´å†…å­˜ç©ºé—´çš„æµªè´¹ã€‚ä¸ºäº†æ»¡è¶³å¯¹é½è¦æ±‚ï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šåœ¨æ•°æ®ä¹‹é—´æ’å…¥å¡«å……ä½ï¼Œè¿™ä¼šå ç”¨é¢å¤–çš„å†…å­˜ç©ºé—´ã€‚ç„¶è€Œï¼Œè¿™ç§å†…å­˜çš„æµªè´¹é€šå¸¸æ¯”èµ·å®ƒå¸¦æ¥çš„æ€§èƒ½æå‡æ¥è¯´æ˜¯å¯ä»¥æ¥å—çš„ã€‚

æ€»çš„æ¥è¯´ï¼Œæ­£ç¡®åœ°å¯¹é½æ•°æ®å¯ä»¥ä½¿ç¡¬ä»¶æ›´æœ‰æ•ˆç‡åœ°å¤„ç†æ•°æ®ï¼Œæé«˜ç¨‹åºçš„è¿è¡Œæ€§èƒ½ï¼Œå‡å°‘å‡ºé”™çš„æœºä¼šï¼Œä½†ä¹Ÿå¯èƒ½å¸¦æ¥ä¸€å®šç¨‹åº¦çš„å†…å­˜æµªè´¹ã€‚

### ç¼“å­˜

CPUå†…æ ¸çš„ç¼“å­˜é€šå¸¸ç”±å¤šä¸ªç¼“å­˜è¡Œï¼ˆcache linesï¼‰æ„æˆã€‚

å½“CPUéœ€è¦è®¿é—®å†…å­˜ä¸­çš„æ•°æ®æ—¶ï¼Œå®ƒä¼šä»¥ç¼“å­˜è¡Œä¸ºå•ä½ä»å†…å­˜ä¸­å–æ•°æ®ï¼Œå¹¶å°†è¿™äº›æ•°æ®å­˜å‚¨åœ¨å®ƒçš„ç¼“å­˜ä¸­ã€‚ç¼“å­˜è¡Œçš„å¤§å°å› å¤„ç†å™¨è€Œå¼‚ï¼Œé€šå¸¸ä¸º64å­—èŠ‚æˆ–128å­—èŠ‚ã€‚æ¯ä¸ªç¼“å­˜è¡Œä¿å­˜äº†ä¸€å—è¿ç»­çš„å†…å­˜æ•°æ®å’Œè¿™å—æ•°æ®çš„åœ°å€ä¿¡æ¯ã€‚

ç”±äºç©ºé—´å±€éƒ¨æ€§ï¼Œç¨‹åºæ¥ä¸‹æ¥å¯èƒ½ä¼šè®¿é—®è¿™å—å†…å­˜é™„è¿‘çš„å…¶ä»–æ•°æ®ï¼Œå¦‚æœè¿™äº›æ•°æ®ä¹Ÿåœ¨åŒä¸€ä¸ªç¼“å­˜è¡Œä¸­ï¼ŒCPUå¯ä»¥ç›´æ¥ä»ç¼“å­˜ä¸­è·å–è¿™äº›æ•°æ®ï¼Œè€Œæ— éœ€ä»å†…å­˜ä¸­å–ï¼Œè¿™å¤§å¤§æé«˜äº†æ•°æ®è®¿é—®çš„é€Ÿåº¦ã€‚

> ä¸¾ä¸ªğŸŒ°ï¼šå‡è®¾Intel Core i7å¤„ç†å™¨çš„L1ç¼“å­˜å¤§å°ä¸º32KBï¼Œé‚£ä¹ˆè¿™ä¸ªç¼“å­˜è¢«åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼šä¸€ä¸ª16KBçš„æ•°æ®ç¼“å­˜å’Œä¸€ä¸ª16KBçš„æŒ‡ä»¤ç¼“å­˜ã€‚åœ¨è¿™æ¬¾å¤„ç†å™¨ä¸­ï¼Œæ¯ä¸ªç¼“å­˜è¡Œçš„å¤§å°ä¸º64å­—èŠ‚ã€‚æ‰€ä»¥ï¼Œå¦‚æœåªæŸ¥çœ‹æ•°æ®ç¼“å­˜ï¼Œé‚£ä¹ˆå¯ä»¥è¯´ï¼Œ16KBçš„æ•°æ®ç¼“å­˜åŒ…å«äº†256ä¸ªç¼“å­˜è¡Œï¼ˆ16KB / 64B = 256ï¼‰ã€‚è¿™äº›ç¼“å­˜è¡Œç”¨äºå­˜å‚¨å¤„ç†å™¨å¯èƒ½ä¼šéœ€è¦çš„æ•°æ®ï¼Œä»è€ŒåŠ å¿«äº†å¤„ç†å™¨è¯»å–å’Œå­˜å‚¨æ•°æ®çš„é€Ÿåº¦ã€‚
>
> **æ¯ä¸ªæ ¸å¿ƒ**éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„32KBçš„L1ç¼“å­˜ã€‚å³æ¯ä¸ªå¤„ç†å™¨æ ¸å¿ƒéƒ½æœ‰ä¸€ä¸ª16KBçš„æ•°æ®ç¼“å­˜å’Œä¸€ä¸ª16KBçš„æŒ‡ä»¤ç¼“å­˜ã€‚å› æ­¤ï¼Œå¯¹äºä¸€ä¸ªæ‹¥æœ‰4ä¸ªæ ¸å¿ƒçš„Intel Core i7å¤„ç†å™¨ï¼Œæ€»å…±å°±ä¼šæœ‰128KBçš„L1ç¼“å­˜ï¼ˆ32KB x 4ï¼‰ã€‚æ­¤å¤–ï¼Œè¿™äº›æ ¸å¿ƒé€šå¸¸è¿˜ä¼šå…±äº«ä¸€äº›æ›´å¤§çš„äºŒçº§ï¼ˆL2ï¼‰å’Œä¸‰çº§ï¼ˆL3ï¼‰ç¼“å­˜ï¼Œè¿™äº›ç¼“å­˜å¯ä»¥å¸®åŠ©åŠ é€Ÿå¤šæ ¸é—´çš„æ•°æ®è®¿é—®å’ŒååŒå·¥ä½œã€‚

![image-20230617235540455](/Users/bytedance/Library/Application Support/typora-user-images/image-20230617235540455.png)

å½“å‘ç”Ÿç¼“å­˜æœªå‘½ä¸­ï¼ˆcache missï¼‰æ—¶ï¼ŒCPUé€šå¸¸ä¼šä»å†…å­˜ä¸­**è·å–éœ€è¦çš„ç¼“å­˜è¡Œï¼Œè€Œä¸æ˜¯æ•´ä¸ªç¼“å­˜**ã€‚

åœ¨CPUè®¿é—®å†…å­˜ä¸­çš„æ•°æ®æ—¶ï¼Œå®ƒå¸¸å¸¸éœ€è¦çš„åªæ˜¯å…¶ä¸­ä¸€éƒ¨åˆ†æ•°æ®ï¼Œä½†CPUä¼šä»¥ç¼“å­˜è¡Œï¼ˆcache lineï¼‰ä¸ºå•ä½ï¼ŒåŠ è½½æ›´å¤šçš„æ•°æ®åˆ°ç¼“å­˜é‡Œã€‚è¿™æ˜¯å› ä¸ºæœ‰ä¸€ä¸ªç§°ä½œå±€éƒ¨æ€§åŸç†ï¼ˆprinciple of localityï¼‰çš„è§‚å¯Ÿç»“æœï¼šå¦‚æœä¸€ä¸ªæ•°æ®è¢«è®¿é—®ï¼Œé‚£ä¹ˆå®ƒé™„è¿‘çš„æ•°æ®åœ¨ä¸ä¹…çš„å°†æ¥ä¹Ÿå¾ˆå¯èƒ½è¢«è®¿é—®ã€‚å› æ­¤ï¼Œå½“ç¼“å­˜æœªå‘½ä¸­æ—¶ï¼ŒCPUä¼šä»å†…å­˜ä¸­è·å–ç¼ºå¤±çš„ç¼“å­˜è¡Œï¼Œå¹¶å­˜å…¥CPUç¼“å­˜ä¸­ã€‚è¿™æ ·ä¸‹æ¬¡CPUè®¿é—®è¿™ä¸ªç¼“å­˜è¡Œä¸­çš„å…¶ä»–æ•°æ®æ—¶ï¼Œå°±å¯ä»¥ç›´æ¥ä»CPUç¼“å­˜ä¸­è·å–ï¼Œè€Œä¸éœ€è¦å†æ¬¡è®¿é—®å†…å­˜ï¼Œä»è€Œæé«˜äº†æ•°æ®è®¿é—®çš„é€Ÿåº¦ã€‚

## è®¾è®¡

ä»ä¸Šé¢çš„åŸºç¡€çŸ¥è¯†å¯ä»¥çœ‹å‡ºï¼Œé—®é¢˜çš„å…³é”®åœ¨äºä¸åŒå¹³å°ä¸‹çš„ç¼“å­˜è¡Œçš„å¤§å°ï¼Œå¦‚æœæˆ‘ä»¬æŠŠæ•°æ®å¯¹é½åˆ°ç¼“å­˜è¡Œä¸€æ ·å¤§æˆ–è€…ç¼“å­˜è¡Œçš„å€æ•°ï¼Œé‚£ä¹ˆå¦‚æœæ›´æ”¹æ•°æ®çš„è¯å°†åªä¼šå¯¼è‡´è¿™ä¸ªç¼“å­˜è¡Œè¢«é‡æ–°åŠ è½½å’ŒåŒæ­¥ï¼Œè€Œä¸ä¼šå½±å“å…¶ä»–çš„æ•°æ®ï¼š

>`CachePadded<T>`çš„å¤§å°æ˜¯å¯ä»¥å®¹çº³ç±»å‹ä¸º`T`çš„å€¼çš„Nå­—èŠ‚çš„æœ€å°å€æ•°ï¼Œå…¶ä¸­Nä¸ºè®¾å¤‡ä¸Šçš„ç¼“å­˜è¡Œé•¿åº¦ï¼›`CachePadded<T>`çš„å¯¹é½æ–¹å¼ä¸ºNå­—èŠ‚å’Œ`T`çš„å¯¹é½æ–¹å¼ä¸­çš„è¾ƒå¤§è€…ã€‚

```rust
#[cfg_attr(
    any(
        target_arch = "x86_64",
        target_arch = "aarch64",
        target_arch = "powerpc64",
    ),
    repr(align(128))
)]
/// .... è¿˜æœ‰å…¶ä»–å¤„ç†å™¨
#[cfg_attr(
    not(any(
        target_arch = "x86_64",
        target_arch = "aarch64",
        target_arch = "powerpc64",
        target_arch = "arm",
        target_arch = "mips",
        target_arch = "mips64",
        target_arch = "riscv32",
        target_arch = "riscv64",
        target_arch = "sparc",
        target_arch = "hexagon",
        target_arch = "m68k",
        target_arch = "s390x",
    )),
    repr(align(64))
)]
pub struct CachePadded<T> {
    value: T,
}

/// å¹¶å‘å®‰å…¨ä¿è¯æ˜¯ç”± T æ¥å®Œæˆçš„ã€‚
unsafe impl<T: Send> Send for CachePadded<T> {}
unsafe impl<T: Sync> Sync for CachePadded<T> {}

// ä¸€äº›å¾ˆåŸºç¡€çš„å¼•ç”¨æ–¹æ³•å®ç°ã€‚
impl<T> CachePadded<T> {
    /// Pads and aligns a value to the length of a cache line.
    ///
    /// # Examples
    ///
    /// ```
    /// use crossbeam_utils::CachePadded;
    ///
    /// let padded_value = CachePadded::new(1);
    /// ```
    pub const fn new(t: T) -> CachePadded<T> {
        CachePadded::<T> { value: t }
    }

    /// Returns the inner value.
    ///
    /// # Examples
    ///
    /// ```
    /// use crossbeam_utils::CachePadded;
    ///
    /// let padded_value = CachePadded::new(7);
    /// let value = padded_value.into_inner();
    /// assert_eq!(value, 7);
    /// ```
    pub fn into_inner(self) -> T {
        self.value
    }
}

impl<T> Deref for CachePadded<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.value
    }
}

impl<T> DerefMut for CachePadded<T> {
    fn deref_mut(&mut self) -> &mut T {
        &mut self.value
    }
}

impl<T: fmt::Debug> fmt::Debug for CachePadded<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CachePadded")
            .field("value", &self.value)
            .finish()
    }
}

impl<T> From<T> for CachePadded<T> {
    fn from(t: T) -> Self {
        CachePadded::new(t)
    }
}
```

# åŸå­è¯»å†™ä¸ volatile

![image-20230619235025514](/Users/bytedance/Library/Application Support/typora-user-images/image-20230619235025514.png)

ä¸Šé¢çš„å›¾æ˜¯ä¸€ä¸ªå¯å‘ï¼Œæˆ‘åœ¨çœ‹`crossbeam::duque::Buffer`çš„å®ç°çš„å®ç°å‘ç°è¿™ä¹ˆä¸€ä¸ªæ³¨é‡Šï¼š

```rust
    /// Writes `task` into the specified `index`.
    ///
    /// This method might be concurrently called with another `read` at the same index, which is
    /// technically speaking a data race and therefore UB. We should use an atomic store here, but
    /// that would be more expensive and difficult to implement generically for all types `T`.
    /// Hence, as a hack, we use a volatile write instead.
    unsafe fn write(&self, index: isize, task: MaybeUninit<T>) {
        ptr::write_volatile(self.at(index).cast::<MaybeUninit<T>>(), task)
    }

    /// Reads a task from the specified `index`.
    ///
    /// This method might be concurrently called with another `write` at the same index, which is
    /// technically speaking a data race and therefore UB. We should use an atomic load here, but
    /// that would be more expensive and difficult to implement generically for all types `T`.
    /// Hence, as a hack, we use a volatile load instead.
    unsafe fn read(&self, index: isize) -> MaybeUninit<T> {
        ptr::read_volatile(self.at(index).cast::<MaybeUninit<T>>())
    }
```

"Volatile" è¿™ä¸ªæœ¯è¯­ä¸€èˆ¬ç”¨åœ¨ç¡¬ä»¶ç¼–ç¨‹ä¸­ï¼Œæ„å‘³è¿™ä¸ªæ“ä½œä¸èƒ½è¢«ç¼–è¯‘å™¨ä¼˜åŒ–æ‰æˆ–è€…é‡æ’åºã€‚è¿™ä½¿å¾—å¼€å‘è€…å¯ä»¥å¯¹æŸäº›ç‰¹å®šçš„å†…å­˜ä½ç½®è¿›è¡Œç›´æ¥çš„è¯»å†™ï¼Œè¿™åœ¨ä¸ç¡¬ä»¶è®¾å¤‡äº¤äº’æ—¶å°¤ä¸ºå…³é”®ã€‚volatile æé†’ç¼–è¯‘å™¨å®ƒåé¢æ‰€å®šä¹‰çš„å˜é‡éšæ—¶éƒ½æœ‰å¯èƒ½æ”¹å˜ï¼Œå› æ­¤ç¼–è¯‘åçš„ç¨‹åºæ¯æ¬¡éœ€è¦å­˜å‚¨æˆ–è¯»å–è¿™ä¸ªå˜é‡çš„æ—¶å€™ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨å¯¹è¯¥å˜é‡ä¸åšä¼˜åŒ–ï¼Œ**éƒ½ä¼šç›´æ¥ä»å˜é‡å†…å­˜åœ°å€ä¸­è¯»å–æ•°æ®ï¼Œä»è€Œå¯ä»¥æä¾›å¯¹ç‰¹æ®Šåœ°å€çš„ç¨³å®šè®¿é—®**ã€‚

å¦‚æœæ²¡æœ‰volatileå…³é”®å­—ï¼Œåˆ™ç¼–è¯‘å™¨å¯èƒ½ä¼˜åŒ–è¯»å–å’Œå­˜å‚¨ï¼Œ**å¯èƒ½æš‚æ—¶ä½¿ç”¨å¯„å­˜å™¨ä¸­çš„å€¼**ï¼Œå¦‚æœè¿™ä¸ªå˜é‡ç”±åˆ«çš„ç¨‹åºæ›´æ–°äº†çš„è¯ï¼Œå°†å‡ºç°ä¸ä¸€è‡´çš„ç°è±¡ã€‚ï¼ˆç®€æ´çš„è¯´å°±æ˜¯ï¼švolatileå…³é”®è¯å½±å“ç¼–è¯‘å™¨ç¼–è¯‘çš„ç»“æœï¼Œç”¨volatileå£°æ˜çš„å˜é‡è¡¨ç¤ºè¯¥å˜é‡éšæ—¶å¯èƒ½å‘ç”Ÿå˜åŒ–ï¼Œä¸è¯¥å˜é‡æœ‰å…³çš„è¿ç®—ï¼Œä¸è¦è¿›è¡Œç¼–è¯‘ä¼˜åŒ–ï¼Œä»¥å…å‡ºé”™ï¼‰ã€‚

ç„¶è€Œï¼Œä»æ¥æ²¡æœ‰è¯´è¿‡ **volatile ä¿è¯å†…å­˜é¡ºåº**ï¼

å½“æˆ‘ä»¬è°ˆè®ºåŸå­å­˜å‚¨å’ŒåŠ è½½ï¼ˆatomic store/loadï¼‰æ—¶ï¼Œæˆ‘ä»¬æŒ‡çš„æ˜¯ä¸€ç§ç‰¹æ®Šçš„å­˜å‚¨å’ŒåŠ è½½æ“ä½œï¼Œè¯¥æ“ä½œä¿è¯äº†åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­å¯¹äºæŸä¸€æ•°æ®çš„è®¿é—®å’Œä¿®æ”¹ä¸ä¼šè¢«æ‰“æ–­ã€‚è¿™ç§ä¿è¯æ˜¯ä¸ºäº†é˜²æ­¢å‡ºç°å¹¶å‘é—®é¢˜ï¼Œä¾‹å¦‚æ•°æ®ç«æ€ï¼ˆdata raceï¼‰ã€‚åŸå­æ“ä½œç”±å¤„ç†å™¨ç›´æ¥æ”¯æŒï¼Œé€šå¸¸éœ€è¦ç‰¹æ®Šçš„å¤„ç†å™¨æŒ‡ä»¤æ¥å®ç°ã€‚è¿™å°±æ„å‘³ç€åŸå­æ“ä½œé€šå¸¸çš„æ‰§è¡Œæ—¶é—´æ¯”æ™®é€šçš„å†…å­˜æ“ä½œè¦é•¿ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¯´åŸå­æ“ä½œåœ¨æ€§èƒ½ä¸Šâ€œæ›´æ˜‚è´µâ€ã€‚

ç°ä»£çš„å¤„ç†å™¨é€šå¸¸æœ‰å¤šä¸ªæ‰§è¡Œæ ¸å¿ƒï¼Œå¯èƒ½ä¼šæœ‰å¤šä¸ªæ ¸å¿ƒåŒæ—¶è¯»å†™åŒä¸€å—å†…å­˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸ºäº†ç»´æŠ¤å†…å­˜ä¸€è‡´æ€§ï¼Œå¤„ç†å™¨å¿…é¡»åœ¨æ‰€æœ‰æ ¸å¿ƒä¹‹é—´åŒæ­¥è¿™ä¸ªåŸå­æ“ä½œã€‚è¿™ä¸ªåŒæ­¥è¿‡ç¨‹ä¹Ÿéœ€è¦æ—¶é—´ï¼Œè¿›ä¸€æ­¥å¢åŠ äº†åŸå­æ“ä½œçš„ä»£ä»·ã€‚

æ­¤å¤–ï¼ŒåŸå­æ“ä½œåœ¨ç¼–ç¨‹ä¸Šä¹Ÿæ›´å¤æ‚ã€‚ä¸ºæ‰€æœ‰ç±»å‹`T`æ³›å‹åœ°å®ç°ä¸€ä¸ªåŸå­å­˜å‚¨æˆ–åŠ è½½éœ€è¦å€ŸåŠ©äºç‰¹æ®Šçš„è¯­è¨€ç‰¹æ€§ï¼Œå¦‚`std::sync::atomic::AtomicUsize`ã€‚å°½ç®¡Rustçš„æ ‡å‡†åº“æä¾›äº†ä¸€äº›åŸºæœ¬ç±»å‹çš„åŸå­ç‰ˆæœ¬ï¼Œä½†æ˜¯ä»»æ„ç±»å‹çš„åŸå­ç‰ˆæœ¬æ˜¯ä¸å­˜åœ¨çš„ã€‚

ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`volatile`æ“ä½œåœ¨ç¡¬ä»¶å±‚é¢ä¸Šä¸éœ€è¦ä¿è¯å¤šæ ¸åŒæ­¥ï¼Œå› æ­¤åœ¨æ€§èƒ½ä¸Šâ€œæ›´ä¾¿å®œâ€ã€‚åœ¨ç¼–ç¨‹ä¸Šä¹Ÿæ›´ç®€å•ï¼Œå› ä¸ºåªéœ€è¦ä½¿ç”¨`core::ptr::write_volatile`æˆ–`core::ptr::read_volatile`å³å¯ã€‚ç„¶è€Œï¼Œ`volatile`æ“ä½œä¸èƒ½é˜»æ­¢æ•°æ®ç«æ€ï¼Œå› æ­¤å¦‚æœå¯èƒ½å­˜åœ¨å¤šçº¿ç¨‹å†™å…¥çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨å®ƒå¯èƒ½ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚
