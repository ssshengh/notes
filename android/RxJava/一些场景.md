## Android 异步场景

RxJava各种线程切换以及操作符很好地解决了 Android 上的主线程和子线程的数据传递，用链式调用的方式完成不同线程的回调。

比如：(请求数据 A) -> (更新 UI) -> (请求数据 B) -> (更新 UI) -> (请求数据 C) -> (更新 UI)

```Kotlin
Thread {
  val a = getDataA(1)
  runOnUiThread {
    val resultA = doSomethingOnMainA(a)
       Thread {
        val b = getDataB(resultA)
            runOnUiThread {
            val resultB = doSomethingOnMainB(b)
           }
        }.start()
     }
}.start()
```

RxJava 用链式调用的方式把上述操作串起来，然后上一级的操作完成后会自动调用下一个操作。

写法比单纯的回调嵌套要更加清晰，更加容易理解，也更好维护和更改代码。

```Kotlin
Observable.just(1)
.observeOn(Schedulers.io())
.map { getDataA(it) }
.observeOn(AndroidSchedulers.mainThread())
.map { doSomethingOnMainA(it) }
.observeOn(Schedulers.io())
.map { getDataB(it) }
.observeOn(AndroidSchedulers.mainThread())
.map { doSomethingOnMainB(it) }.subscribe { log("") }
```

### Retrofit 中的使用

RxJava 形式的 API：

```Kotlin
@GET("/user")
public Observable<User> getUser(@Query("userId") String userId);
```

Retrofit 把请求封装进 `Observable` 。使用的时候是这样的：

```TypeScript
getUser(userId)
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer<User>() {
    @Override
    public void onNext(User user) {
        userView.setUser(user);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable error) {
        // Error handling
        ...
    }
});
```

定义subscriber # onNext 、onError：在请求结束后处理请求结果

再举一个例子：先请求一个token，用token请求userinfo：

`Callback` 方式，可以使用嵌套的 `Callback`：

```Java
@GET("/token")
public void getToken(Callback<String> callback);

@GET("/user")
public void getUserInfo(@Query("token") String token, @Query("userId") String userId, Callback<User> callback);

...

getToken(new Callback<String>() {
    @Override
    public void success(String token) {
        getUserInfo(token, userId, new Callback<User>() {
            @Override
            public void success(User user) {
                userView.setUser(user);
            }
    
            @Override
            public void failure(RetrofitError error) {
                // Error handling
                ...
            }
        };
    }
    
    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
});
```

使用 RxJava 的话：

```Java
@GET("/token")
public Observable<String> getToken();

@GET("/user")
public Observable<User> getUserInfo(@Query("token") String token, @Query("userId") String userId);

...

getToken()
    .flatMap(new Func1<String, Observable<User>>() {
        @Override
        public Observable<User> onNext(String token) {
            return getUserInfo(token, userId);
        })
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer<User>() {
        @Override
        public void onNext(User user) {
            userView.setUser(user);
        }
        
        @Override
        public void onCompleted() {
        }
        
        @Override
        public void onError(Throwable error) {
            // Error handling
            ...
        }
    });
```