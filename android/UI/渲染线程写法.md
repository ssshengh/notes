## 背景介绍

有的时候我们需要实现一个白板、视频展示或者游戏相关的交互式动画，此时需要一帧一帧的进行渲染。传统的写法是通过 While 来进行死循环，并基于 Channel 等方式进行通信。

但是在安卓中我们可以有更好的写法。这也是本篇文章探讨的主题。本文分为三部分：

1. 如何写一个渲染线程
2. canvas 的基本使用
3. 一个白板小 demo

## 渲染线程写法

### 基于 Handler 的渲染线程

写一个处理特殊事件的死循环线程很简单：

```kotlin
Thread {
    while () {
			 // 不断的接收渲染事件并进行渲染
    }
}
```

例如上面的代码，我们可以简单的用一个 while 循环来实现渲染循环。但是问题在于，上面的写法中：

1. CPU 会持续性的被占用
2. 前后两次 while 执行之间可能间隔过短
3. 上一次渲染任务如果很耗时的话，需要侵入式的通过一个 timer 去取消任务

因此，实际上我们按照一定帧率进行渲染的时候，一般都不会使用 while 死循环的方式，而是借助 Handler 来完成。我们可以把基于 while 的渲染循环改写为以下的形式：

```kotlin
inner class WbThread(val name: String) {
  	// 本线程的 handler 实现
    @Volatile
    private var mHandler: Handler? = null
  	// 渲染间隔，60 帧
    private val drawInterval = 16L
  
  	// 渲染线程
    private val renderRunnable: Runnable = Runnable {
        val tm = duration { pullDataAndRender() }
        removeRenderTasks()
        postRenderTaskDelay(max(drawInterval - tm, 0))
    }
		
  	// 渲染核心方法
    private fun pullDataAndRender() {
        synchronized(rendering) {
            pullData()
            onRender() 
        }
    }
		
  	// 开始渲染循环
    fun start() {
        val thread = HandlerThread(name + hashCode())
        thread.start()
        mHandler = Handler(thread.looper)
        mHandler?.post(renderRunnable)
    }
  
  	
		// 插入任务到渲染循环中
    fun post(runnable: Runnable) {
        mHandler?.post(runnable)
    }
		
  	// 重新调度渲染任务
    fun rescheduleRenderTask() {
        removeRenderTasks()
        postRenderTaskDelay(0)
    }

    private fun postRenderTaskDelay(delay: Long) {
        mHandler?.postDelayed(renderRunnable, delay)
    }

    private fun removeRenderTasks() {
        mHandler?.removeCallbacks(renderRunnable)
    }

    fun quit() {
        mHandler?.removeCallbacksAndMessages(null)
        mHandler?.looper?.quit()
        mHandler = null
    }

    fun quitWithJoin(timeout: Long) {
        try {
            mHandler?.removeCallbacksAndMessages(null)
            mHandler?.looper?.quit()
            mHandler?.looper?.thread?.join(timeout)
        } catch (throwable: Throwable) {
            Log.e(TAG, "[quitWithJoin] catch throwable=${throwable.message}")
        }
        mHandler = null
    }

    fun isAlive(): Boolean {
        return mHandler?.looper?.thread?.isAlive ?: false
    }

    fun getThreadId(): Long? {
        return mHandler?.looper?.thread?.id
    }
}
```

上面的代码内容较多，一点一点的来说。首先是渲染本身：

```kotlin
private val renderRunnable: Runnable = Runnable {
    val tm = duration { pullDataAndRender() }
    removeRenderTasks()
    postRenderTaskDelay(max(drawInterval - tm, 0))
}

private fun removeRenderTasks() {
    mHandler?.removeCallbacks(renderRunnable)
}

private fun postRenderTaskDelay(delay: Long) {
    mHandler?.postDelayed(renderRunnable, delay)
}
```

总共只干了三件事：

1. 拉取数据并获取时间
2. 移除上一次的渲染任务
3. 如果时延间隔大于 16ms 的话，重新渲染

这样写我们就能够确保任务的执行不用那么快，稳定刷新的帧率，如果此次渲染时间较短的话，我们可以拉平时延，看着不会跳动。当然，这种方案的问题在于，如果此次拉取数据并渲染的时延比较大的话，此时会吞掉几帧，像游戏中卡帧一样。

然后就是该渲染的对外接口，其中启动接口比较简单：

```kotlin
fun start() {
    val thread = HandlerThread(name + hashCode())
    thread.start()
    mHandler = Handler(thread.looper)
    mHandler?.post(renderRunnable)
}
```

我们确保在启动渲染的时候才创建当前的渲染线程，并抛出第一个渲染任务。

结束的时候有两种方法：

```kotlin
fun quit() {
    mHandler?.removeCallbacksAndMessages(null)
    mHandler?.looper?.quit()
    mHandler = null
}

fun quitWithJoin(timeout: Long) {
    try {
        mHandler?.removeCallbacksAndMessages(null)
        mHandler?.looper?.quit()
        mHandler?.looper?.thread?.join(timeout)
    } catch (throwable: Throwable) {
        Log.e(TAG, "[quitWithJoin] catch throwable=${throwable.message}")
    }
    mHandler = null
}
```

一种是粗暴的结束，另一种是等待当前任务执行完毕，对于实时渲染场景来说，join 的方案会更好些。

此外，渲染线程可能还需要处理一些额外的数据，这些数据无法以固定帧的形式在每一次执行任务的时候通过 pullData 来完成，这时候我们就需要另一类的 task：

```k
fun post(runnable: Runnable) {
    mHandler?.post(runnable)
}
```

### 对外API

在了解了上面的设计逻辑之后，我们可以对外暴露关键的 API 了。API 的设计主要需要考虑开始结束两个生命周期相关的内容：

```ko
/**
 * 主线程调用
 */
fun startRender() {
    Log.i(TAG, "[startRender]")
    if (wbThread == null) {
        Log.i(TAG, "[onStartRender] [startRender]")
        wbThread = WbThread("WbThread")
        wbThread?.start()
    }
    rendering.set(true)
}

/**
 * 主线程调用
 */
fun stopRender() {
    Log.i(TAG, "[stopRender]")
    rendering.set(false)
    wbThread?.quitWithJoin(JOIN_TIMEOUT)
    wbThread = null
}
```

需要注意的是，我们需要确保开始与关闭在同一个线程中去完成，避免出现时序问题，而比较简单的方式就是在主线程中的调用。

除了关闭之外，我们还需要考虑销毁的策略：

```kotlin
/**
 * 销毁方法，区别于 stopRender，为了和 surfaceDestroy 中 runOnRenderThread 的逻辑串行执行
 */
fun destroy() {
    Log.i(TAG, "[destroy]")
    runOnRenderThread {
        Log.i(TAG, "[destroy] runOnRenderThread")
        rendering.set(false)
        wbThread?.quit()
        wbThread = null
    }
}
```

其逻辑和关闭差不多，关键点在于我们将执行线程放到了渲染线程本身中。他主要使用的场景如注释中一样，应该是在 SurfaceView 的 destroy 回调中去调用，而由于此时 View 已经被销毁了，因此应该是立刻 quit，而不用 join 线程了。

除了这三个重要的 API 外，还有两个比较实用的工具 API：
```kotlin
// 计算渲染时延
internal inline fun duration(block: () -> Unit): Long {
    val tm = System.currentTimeMillis()
    block()
    return System.currentTimeMillis() - tm
}

// 抛任务到渲染线程
fun runOnRenderThread(task: Runnable) {
    wbThread?.post(task)
}
```



## Canvas 的基本使用





# 附录

## 渲染线程源码

```kotlin
package com.example.mvilearn.view.whiteboard

import android.os.Handler
import android.os.HandlerThread
import android.util.Log
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.math.max

class Render {

    /**
     * 正在渲染标记位
     */
    private val rendering: AtomicBoolean = AtomicBoolean(false)

    /**
     * 启动 render 任务的线程
     */
    private var wbThread: WbThread? = null
    

    fun runOnRenderThread(task: Runnable) {
        wbThread?.post(task)
    }
  
    /**
     * 从数据源获取数据
     */
    private fun pullData() {
        Log.i(TAG, "[pullData]")
    }

    /**
     * 渲染核心方法
     */
    private fun onRender() {
        Log.d(TAG, "[onRender] rendering=$rendering")
        if (!rendering.get()) {
            return
        }
    }

    /**
     * 获取渲染线程的 thread id
     */
    fun getRenderThreadId(): Long? =
        wbThread?.getThreadId()

    /**
     * 主线程调用
     */
    fun startRender() {
        Log.i(TAG, "[startRender]")
        if (wbThread == null) {
            Log.i(TAG, "[onStartRender] [startRender]")
            wbThread = WbThread("WbThread")
            wbThread?.start()
        }
        rendering.set(true)
    }

    /**
     * 主线程调用
     */
    fun stopRender() {
        Log.i(TAG, "[stopRender]")
        rendering.set(false)
        wbThread?.quitWithJoin(JOIN_TIMEOUT)
        wbThread = null
    }

    /**
     * 销毁方法，区别于 stopRender，为了和 surfaceDestroy 中 runOnRenderThread 的逻辑串行执行
     */
    fun destroy() {
        Log.i(TAG, "[destroy]")
        runOnRenderThread {
            Log.i(TAG, "[destroy] runOnRenderThread")
            rendering.set(false)
            wbThread?.quit()
            wbThread = null
        }
    }
    
    inner class WbThread(val name: String) {
        @Volatile
        private var mHandler: Handler? = null
        private val drawInterval = 16L
        private val renderRunnable: Runnable = Runnable {
            val tm = duration { pullDataAndRender() }
            removeRenderTasks()
            postRenderTaskDelay(max(drawInterval - tm, 0))
        }

        private fun pullDataAndRender() {
            synchronized(rendering) {
                pullData()
                onRender() 
            }
        }

        fun start() {
            val thread = HandlerThread(name + hashCode())
            thread.start()
            mHandler = Handler(thread.looper)
            mHandler?.post(renderRunnable)
        }

        fun post(runnable: Runnable) {
            mHandler?.post(runnable)
        }

        fun rescheduleRenderTask() {
            removeRenderTasks()
            postRenderTaskDelay(0)
        }

        private fun postRenderTaskDelay(delay: Long) {
            mHandler?.postDelayed(renderRunnable, delay)
        }

        private fun removeRenderTasks() {
            mHandler?.removeCallbacks(renderRunnable)
        }

        fun quit() {
            mHandler?.removeCallbacksAndMessages(null)
            mHandler?.looper?.quit()
            mHandler = null
        }

        fun quitWithJoin(timeout: Long) {
            try {
                mHandler?.removeCallbacksAndMessages(null)
                mHandler?.looper?.quit()
                mHandler?.looper?.thread?.join(timeout)
            } catch (throwable: Throwable) {
                Log.e(TAG, "[quitWithJoin] catch throwable=${throwable.message}")
            }
            mHandler = null
        }

        fun isAlive(): Boolean {
            return mHandler?.looper?.thread?.isAlive ?: false
        }

        fun getThreadId(): Long? {
            return mHandler?.looper?.thread?.id
        }
    }
    
    companion object {
        private const val TAG = "Render"
        private const val JOIN_TIMEOUT = 1000L
    }

    internal inline fun duration(block: () -> Unit): Long {
        val tm = System.currentTimeMillis()
        block()
        return System.currentTimeMillis() - tm
    }
}
```

