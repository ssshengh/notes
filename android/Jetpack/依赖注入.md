# Android 中的依赖注入

## 依赖注入简介

类通常需要引用其他类。例如，`Car` 类可能需要引用 `Engine` 类。这些必需的类称为依赖项，在此示例中，`Car` 类必须拥有 `Engine` 类的一个实例才能运行。类可通过以下三种方式获取所需的对象：

1. 类构造其所需的依赖项，例如：`Car` 将创建并初始化自己的 `Engine` 实例。

   ```java
   class Car {
   	  // 类中直接持有 Engine 对象并 new
       private Engine engine = new Engine();
   
       public void start() {
           engine.start();
       }
   }
   
   
   class MyApp {
       public static void main(String[] args) {
           Car car = new Car();
           car.start();
       }
   }
   ```

2. 从其他地方获取。某些 Android API（如 `Context` getter 和 `getSystemService()`）便是如此获取对象的。

3. 以参数形式提供。应用可以在构造类时提供这些依赖项，或者将这些依赖项传入需要各个依赖项的函数。例如：`Car` 构造函数将接收 `Engine` 作为参数。

   ```java
   class Car {
   	  // 类中只是由 Engine 字段，但是没有对象，对象由外部给入
       private final Engine engine;
   
       public Car(Engine engine) {
           this.engine = engine;
       }
   
       public void start() {
           engine.start();
       }
   }
   
   
   class MyApp {
       public static void main(String[] args) {
           Engine engine = new Engine();
         	// 构造 car 对象时传入 Engine 对象
           Car car = new Car(engine);
           car.start();
       }
   }
   ```

我们将这种传参进入构造函数，使得类可以持有参数中对象的方式称为依赖注入(DI)

Android 中实现依赖项注入的方式主要有两种：

- **构造函数注入**。这就是上面描述的方式。您将某个类的依赖项传入其构造函数。

- **字段注入（或 setter 注入）**。某些 Android 框架类（如 activity 和 fragment）由系统实例化，因此无法进行构造函数注入。使用字段注入时，依赖项将在创建类后实例化。代码如下所示：

  ```java
  class Car {
  
      private Engine engine;
  
      public void setEngine(Engine engine) {
          this.engine = engine;
      }
  
      public void start() {
          engine.start();
      }
  }
  
  class MyApp {
      public static void main(String[] args) {
          Car car = new Car();
        	// 通过一个 set 方法后期注入，这个也是很常见的策略
          car.setEngine(new Engine());
          car.start();
      }
  }
  ```

在上面示例中，我们没有依赖于某个库(类似于 Spring，自行创建、提供并管理了不同类的依赖项)。这称为手动依赖项注入或人工依赖项注入。在 `Car` 示例中，只有一个依赖项，但依赖项和类越多，手动依赖项注入就越繁琐。手动依赖项注入还会带来多个问题：

- 对于大型应用，获取所有依赖项并正确连接它们可能需要大量样板代码。**在多层架构中，要为顶层创建一个对象，必须提供下层的所有依赖项**。例如，要制造一辆真车，可能需要引擎、变速器、底盘以及其他部件；而要制造引擎，则需要汽缸和火花塞。
- 如果您无法在传入依赖项之前构造依赖项（例如，当使用延迟初始化或将对象作用域限定为应用流时），则需要编写并维护用于管理内存中依赖项生命周期的自定义容器（或依赖关系图）。

有一些库通过自动执行创建和提供依赖项的过程解决此问题。它们归为两类：

- **基于反射的解决方案**，可在运行时连接依赖项。
- **静态解决方案**，可在编译时生成连接依赖项的代码。

[Dagger](https://dagger.dev/) 是适用于 Java、Kotlin 和 Android 的 DI 库，由 Google 进行维护。Dagger 会为我们创建和管理依赖关系图，方便您在应用中使用 DI。它提供了**完全静态和编译时依赖项**，解决了基于反射的解决方案（如 [Guice](https://en.wikipedia.org/wiki/Google_Guice)）的诸多开发和性能问题。

> 当然，DI 还可以使用全局的 object 或者说单例类来解决获取依赖项的问题，但是全局类相比 DI 有几个大问题：
>
> 1. object 所需的依赖项集合使得代码更难测试，因为所有测试都必须与同一全局 object 进行交互。
> 2. 依赖项在类实现中编码，而不是在 API surface 中编码。因此，很难从外部了解类需要什么。所以，更改 `Car` 或 object 中可用的依赖项可能会导致引用失败，从而导致运行时或测试失败。
> 3. 如果有需求将作用域限定为除了整个应用的生命周期之外的任何区间，此时会难以管理对象的生命周期。

## Hilt

[Hilt](https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn) 是推荐用于在 Android 中实现依赖项注入的 Jetpack 库。Hilt 定义了一种在应用中实现 DI 的标准方法，它会为项目中的每个 Android 类提供容器并自动为您管理其生命周期。Hilt 在热门 DI 库 [Dagger](https://developer.android.com/training/dependency-injection/dagger-basics?hl=zh-cn) 的基础上构建而成，因而能够受益于 Dagger 提供的编译时正确性、运行时性能、可伸缩性和 Android Studio 支持。